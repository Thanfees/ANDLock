#!/system/bin/sh

MODULE_DIR="/data/adb/modules/lockdown"
LOG_DIR="$MODULE_DIR/logs"
LOG_FILE="$LOG_DIR/malware_scan.log"
MAX_LOG_LINES=400

mkdir -p "$LOG_DIR"

timestamp="$(date '+%Y-%m-%d %H:%M:%S')"
echo "==== Malware Scan ${timestamp} ====" >> "$LOG_FILE"

found=0

# Pull process list once to flag common tooling used by malware operators
PS_OUTPUT="$(ps -A 2>/dev/null)"
if [ -z "$PS_OUTPUT" ]; then
    PS_OUTPUT="$(ps 2>/dev/null)"
fi

is_package_suspicious() {
    pkg_name="$1"
    pkg_lc="$(echo "$pkg_name" | tr 'A-Z' 'a-z')"

    case "$pkg_name" in
        com.android.system.v1|com.cleaner.cleanphone|com.cleanercore.speedboost|\
        com.superspeed.clean|com.devicestalker.spy|com.app.accessibilityspy|\
        com.system.update.engine|com.android.updateservice|com.service.system) return 0 ;;
    esac

    case "$pkg_lc" in
        *spy*|*stalker*|*monitor*|*keylog*|*rat*|*stealth*|*remote*viewer*) return 0 ;;
    esac

    return 1
}

classify_risk() {
    score="$1"
    if [ "$score" -ge 5 ]; then
        echo "HIGH"
    elif [ "$score" -ge 3 ]; then
        echo "MEDIUM"
    else
        echo "LOW"
    fi
}

packages="$(pm list packages -3 | cut -d ':' -f 2)"

for pkg in $packages; do
    risk_score=0
    reasons=""

    if is_package_suspicious "$pkg"; then
        risk_score=$((risk_score + 3))
        reasons="${reasons}Known malicious signature; "
    fi

    pkg_info="$(dumpsys package "$pkg" 2>/dev/null)"
    [ -z "$pkg_info" ] && continue

    if echo "$pkg_info" | grep -q "android.permission.BIND_ACCESSIBILITY_SERVICE"; then
        risk_score=$((risk_score + 2))
        reasons="${reasons}Accessibility service takeover; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.BIND_DEVICE_ADMIN"; then
        risk_score=$((risk_score + 2))
        reasons="${reasons}Device admin binding; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.REQUEST_INSTALL_PACKAGES"; then
        risk_score=$((risk_score + 1))
        reasons="${reasons}Side-loading capability; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.SYSTEM_ALERT_WINDOW"; then
        risk_score=$((risk_score + 1))
        reasons="${reasons}Overlay permission; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.READ_SMS"; then
        risk_score=$((risk_score + 1))
        reasons="${reasons}SMS read access; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.RECEIVE_SMS"; then
        risk_score=$((risk_score + 1))
        reasons="${reasons}SMS interception; "
    fi

    if echo "$pkg_info" | grep -q "android.permission.RECORD_AUDIO"; then
        risk_score=$((risk_score + 1))
        reasons="${reasons}Audio recording; "
    fi

    code_path="$(echo "$pkg_info" | grep -m1 'codePath=' | cut -d'=' -f2)"
    if echo "$code_path" | grep -qE '/data/local|/sdcard|/storage'; then
        risk_score=$((risk_score + 3))
        reasons="${reasons}Unusual code path (${code_path}); "
    fi

    if [ "$risk_score" -gt 0 ]; then
        severity="$(classify_risk "$risk_score")"
        found=1
        echo "[$severity] $pkg -> ${reasons}" >> "$LOG_FILE"
        echo "[Lockdown] Suspicious package detected: $pkg (${severity})"
    fi
done

for marker in frida-server frida32 frida64 objection drozer xposed_service xposeddaemon httpcanarymagisk zanti csploit bettercap; do
    if [ -n "$PS_OUTPUT" ] && echo "$PS_OUTPUT" | grep -q "$marker"; then
        found=1
        echo "[PROCESS] Suspicious process \"$marker\" detected in process list." >> "$LOG_FILE"
        echo "[Lockdown] Suspicious process detected: $marker"
    fi
done

if [ "$found" -eq 0 ]; then
    echo "No suspicious packages or processes detected." >> "$LOG_FILE"
    echo "[Lockdown] Malware scan completed: no issues found."
else
    echo "Malware scan completed with findings. Review ${LOG_FILE} for details." >> "$LOG_FILE"
    echo "[Lockdown] Malware scan completed with findings. See ${LOG_FILE}."
fi

if [ -f "$LOG_FILE" ]; then
    total_lines="$(wc -l < "$LOG_FILE")"
    if [ "$total_lines" -gt "$MAX_LOG_LINES" ]; then
        tail -n "$MAX_LOG_LINES" "$LOG_FILE" > "${LOG_FILE}.tmp"
        mv "${LOG_FILE}.tmp" "$LOG_FILE"
    fi
fi
